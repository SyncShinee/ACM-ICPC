B 及格率 
方法一：用总人数/及格率，并上取整，算出及格人数，将分数从大到小排序后输出数组中的对应位置。但此方法要特判及格率为0，结果为100分的情况 
方法二：暴力从100~0逆序枚举及格线，得到最大符合要求的即为所求 
  
C 01串 
基础动态规划。 
dp[i][0 or 1]表示在位置i取值为0或者为1能够得到的最大完美01串的长度。 
下面考虑状态转移： 
1.    在位置i上取‘0’，dp[i][0] = dp[i-1][1] + 1，dp[i][1]无效； 
2.    在位置i上取‘1’，dp[i][1] = dp[i-1][0] + 1，dp[i][0]无效； 
3.    在位置i上取‘?’，因为‘?’可以取‘0’或‘1’，所以上两个状态转移式都有效。 
dp数组中的最大值即为所求 
  
D Alice and Bob 
博弈。设Alice和Bob之间的距离为dis 
首先判断Alice是否能在第一次移动时就获胜，即a>=dis； 
两人所能到达的位置都是以自己为圆心，半径为自己所能到达的最大距离的圆。以Alice为例，一旦她移动完以后和Bob的距离小于等于b，那么Bob将获胜，但如果她在移动之前和Bob的距离小于等于a，则Alice将获胜。所以只要保证2*b<a则Alice必胜，同理2*a<b Bob 必胜。否则为平手。注意，以上两个判断条件都不能取等以及浮点数之间的判断。 
  
E 光线传播 
性质1：对于两束光线(X_a, angle_a)和(X_b, angle_b)（不妨设X_a < X_b），则他们不相交的充要条件是angla_a >= angle_b。 
性质2：对于两条相交的光线，显然仅有垂直方向速度较大的光线可能射向无穷远处。 
  
基于这两个性质，我们可以得到一个浅显的做法。首先，将所有光线按x坐标从小到大排序，根据性质1 ，最后剩下的光线的angle必然是单调不增的。也就是说，对于当前枚举到的光线，如果它和当前留下的X坐标最大的光线不相交，则它与其他当前合法的光线都不相交。 
于是我们维护一个栈按X坐标存放所有的合法光线。当插入一束新光线时， 若它与栈顶光线不相交则放入栈中，否则，若与栈顶光线相交但被栈顶光线阻碍（即该光线垂直方向速度较小），则舍弃该光线（即不进栈）。若该光线会阻碍栈顶光线，则弹出栈顶光线，再判断该光线与新的栈顶光线的关系，直到它最终进栈或者被舍弃。 
当所有光线都判断过之后，当前栈中光线即最后能射向无穷远处的光线，其数量即所求。 
  
F 行侠仗义 
中等难度动态规划。 
注意到这题的数据范围，每个人的智商初始值ai<=200，即至多8次ai就会降到0，而之后无论怎么发射光波，都不会起作用了。 
注意到：若相邻的两个人智商都为a，S值会增加2a， 
由此，我们可以想到，已知第i-1个人的智商，再枚举第i个人被降智商的次数(0~8)，进而求出当前情况下的前i个人的S值，以此进行状态转移。 
一种可行的状态转移为： 
dp[i][j][k]表示前i个人共降了j次智商，且第i个人被降k次智商情况下，前i个人的S最小值。 
若第i-1个人被降l次智商，则其当前的智商值为a[i-1]/2^l，第i个人被降智商的次数为k，则其智商值为a[i]/2^k，dp[i][j][k] = min{ dp[i-1][j-k][l] + a[i]/2^k + add }, 当a[i-1]/2^l = a[i]/2^k时，add=2*a[i]/2^k ; 否则add = 0。 
  
G 珍珠链 
一个显然的性质是：如果链子的颜色全部相同，则一个也不能消去；否则当链长N大于2时，用数学归纳法可以证明，它一定可以消成N – 1长度的链子。因此最后的答案只有三种情况：N, 2或者1。 
我们来讨论一下在什么情况下会得到1和2。 
1. rg，消为b； 
2. rgb,只能消为rr或bb； 
考虑怎样的链子可以消成上述第两种情况。每次只能把两颗不同的消去，再增加一颗第三种颜色的。 
rgb的上一步只有 rgrg，rrgg，rggr三种形式，并且它们的下一步一定为rgb或其排列组合。以此类推，将四颗的链子扩成五颗时，其子序列的形式一定为上述三种形式，而在将rgb不断扩展时，对三种颜色的珠子的数量而言，每次操作，一定是两个减一，一个加一。如果三个珠子数量是同奇偶的，则改变后，其奇偶性都改变一次，仍未同奇偶的；若本不同奇偶，则改变后亦为非同奇偶。反过来推导也可以得到同样的结论。 
故一共有三种情况； 
1. 若珠子只有一种颜色，答案为N； 
2. 若三种颜色的数量同奇偶(0是偶数），则答案是2； 
3. 不满足前两个条件时，答案为1。 
  
H 矩阵 
考察字符串的hash 
将矩阵hash的方法：按行hash得到压缩后的一个列数组，再按该列数组hash，得到整个矩阵的hash值。 
对于大矩形，我们可以预处理出来所有的k*k的矩阵的hash值，复杂度为O(n*m*k)，然后对于每一个查询，计算出小矩阵的hash值，再判断该值是否在大矩阵中出现过即可，查询的复杂度为O(Q*k*k)。这题的数据比较宽松，O(Q*K^2*log(n * m * k))是允许通过的。 
  
I 报名注册 
简单题，考察基本编程能力。按规则筛选满足所有条件的即可。 
  
-- 